\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{hyperref}
\usepackage{hhline}
\hypersetup{colorlinks=true, linkcolor=black, urlcolor=blue}

\title{Project Experiences version 3.0 \\ The Traffic-o-meter}
\author{Group D\\ Mattias Eklund, Philip Holgersson, Emma Holmberg Ohlsson,\\ Hannes Johansson, Johan Mattsson, Alexander Nässlander\\Martin Richter, Fredrik Åkerberg}
\date{\today}

\begin{document}
	\maketitle
	\thispagestyle{empty}
	\setcounter{page}{0}
	\pagebreak
	\tableofcontents
	\pagebreak
	
	\section{About this document}
We have done a project in the course requirements engineering. The project consisted of two parts, one part where we produced a requirements specification for another group and one part where we were clients to another group. The bigger part was making a system requirements specification. For the actual requirements specification, check out the document systemRequirements.pdf. This report describes the process used, techniques chosen and why, learning outcomes and a personal statement from each team member on their individual contribution.

	\section{Elicitation Methods/Techniques}
	%Description of the techniques
	%Why we have chosen these methods, what did we want from the different 
Lauesen describes elicitation as "the process of finding and formulating requirements". Elicitation is used for identifying the core values of the project as well as desired features and functions. Identifying requirements seems like a rather simple task but there are several issues that cause a severe threat to the project success. For example that a client cannot express what they need or that they try to give a solution instead of explaining what problem they want solved. These problems are called elicitation barriers. To overcome the elicitation barriers we use elicitation techniques. The best way to overcome the elicitation barriers is to use several elicitation techniques and getting input from different stakeholders. An elicitation technique is a well defined method for researching a specific topic. Some methods that can be used as elicitation techniques are focus group, design workshop or stakeholder analysis. Exactly which elicitation techniques to use depends on the context. In our project we used a few different techniques to approach the problem from different angles. This section explains the techniques we used and how they applied to our project.
	\subsection{Brainstorming}
Brainstorming is a technique where the participants toss around words or ideas that they have. In a typical brainstorming session there is a high tolerance of suggestions and no idea or thought is discarded or neglected. Brainstorming can be used frequently throughout the project.
		\subsubsection{Application}
We used brainstorming mainly in the beginning in the project in order to get a clear idea of the problem we were facing. The process was done in iterations since every session raised new questions that needed to be addressed. The first iterations gave a wider outline of the project and the latter were more detail oriented. Not all sessions were structured and might have been more of group discussions rather than brainstorming.
		\subsubsection{Why chosen}
Brainstorming is a good method to use in the beginning of a project to get started. One reason for this is that brainstorming is a good way to get a grip of the current situation in a project and get an idea of the problem at hand. It is an easy to use method that does not require a lot of preparation or material. It is quite fast and the result is direct. Just a couple of people from the project group can brainstorm for 10 minutes on a topic and then share with the rest of the group what they came up with. 

		\subsubsection{Outcome}
		 We chose this method to get a better overview of what other techniques we would need to use later in the project and get a good foundation from which to progress further in our elicitation. Other than a more concrete idea, the brainstorming also yielded some requirements for the system, such as that it should consist of both an app and a widget. We also realised that we would need to do some research and ask the potential end users what sort of functionality they would want the product to have. We also realised that we would need to have some sort of workshop with the customers to get them to better explain their needs. It also helped us to decide on the idea for the project in which we are clients, Boogle Calender.

		\subsection{Stakeholder analysis}
 This method is used to identify the people or organizations who are needed to ensure the success of the project. It is important not only to identify the stakeholders but also to find their interests and goals with the project. It can be of good help to have a set of questions you want answers to when you do the stakeholder analysis.

		\begin{itemize}
			\item Who are the stakeholders?
			\item What goals do they see for the system?
			\item Why would they like to contribute?
			\item What risks and costs do they see?
			\item What kind of solutions and suppliers do they see?
		\end{itemize}
		
		\subsubsection{Application}
 We combined brainstorming and stakeholder analysis to answer the questions above. This was done mostly within the group but we also discussed with our clients and with our supervisor.
		\subsubsection{Why chosen}
		Identifying the stakeholders in the beginning of the project will allow us to elicit more requirements early on. By knowing the stakeholders we can divide the requirements in to certain groups, which makes the specification and validation easier.
		\subsubsection{Outcome}
We came to the insight for whom we are really making the system. This led to a meeting with our customers in which we realized that the government should be included, which is something that we hadn't discussed before.
	The following stakeholders were identified:

		\begin{itemize}
			\item The commuters (the target users).
			\item The product owner. (Our clients)
			\item The regional public transportation companies (Länstrafikbolagen). 
			\item The Swedish Government\footnote{Forgotten during stakeholder analysis but added during the construction of the Context diagram, see section \ref{subsec:context}}.
		\end{itemize}
				
		\subsection{Similar companies}
			In order to get inspiration and see what similar services there are today, it can be a good idea to look at competitors' or partners' services. This is not a technique in itself but is often used with for example observation.
	
		\subsubsection{Application}
			We decided to try the following services and combine it with an informal observation study where one person used the app and tried different features while another one observed. We discussed the individual alternatives during the experiment and compared them afterwards. The ones we looked at are:
			\begin{itemize}
				\item SL app and widget (Regional in Stockholm)
				\item Västtrafik app and widget (Regional in Gothenburg)
				\item Skånetrafiken app and widget (Regional in Skåne)
				\item SJ mobile web page and app (Interregional trains Sweden)
			\end{itemize}
	
		\subsubsection{Why chosen}
		We used this method to get an idea of what a finished product might look like and to get inspiration on features to include in our solution.
		\subsubsection{Outcome}
		Observing and analysing other companies' solutions to the problem helped us to develop many of our system requirements and it generated questions that we could discuss with our customers to get a better final product. The members of our team have, more or less, all used applications similar to the one we were supposed to develop. This in it self gave some domain knowledge and ideas of what could be implemented. Examples of what requirements that emerged during this phase is the maximum distance to walk and minimum time to wait at a switch.


		\subsection{Focus group \& design workshop}
		A focus group is a sort of group interview with a moderator leading the discussion. Focus groups are typically used to get the opinions or attitudes of people towards a service or product. A design workshop is a session where you combine brainstorming with prototyping of some kind.
		\subsubsection{Application}
		We decided to combine a focus group with a design workshop as the topic was the same. We wanted to find out more about what the user expected to see on the screen and what they would use the service for. The first part was the focus group where we had questions that participants discussed and in the second part they got to make their own low-fi prototypes of what they imagine/want the widget and app to look like. We cut out papers in the size of a phone so they would be able to make realistic drawings. Using a big paper could risk that they disregard the limited amount of space and try to put too much information.
	
		\subsubsection{Why chosen}
We used this method in order to get input from potential users. It was important that the participants could be objective and had not heard about the project before, so we contacted people that were not taking the course.
		\subsubsection{Outcome}
We found out that the potential users did not want too much information and that a maximum of 3 destinations is enough to display. Their prototypes focused mainly on when the first departure is and where to go from here, rather than the final destination or total travel time. We also learned that it was quite important for the users that the service would be smart, meaning that it should learn what is your home/office/school. Another desired function was that the destinations showed varied depending on the current position of the phone. This last request was something we brought up with our clients and something they strongly did not want. Since we are doing this firstly for our clients, we chose to satisfy them rather than potential users.
	
	\section{Specification Methods/Techniques}
	Finding the requirements is only a fraction of the requirements process. Defining and documenting them is the second step, which is known as requirements specification. This subprocess of requirements engineering involves how we want to present the requirements as well as defining what kind of requirements they are. How to represent different requirements depend on what level they are on which kind of requirement it is (data requirement, quality requirement, feature requirement etcetera). Under
levels we explain how the different levels of requirements relate to our requirements.  Later on we explain the different techniques we used for specification and what we got out of them.

	\subsection{Levels}

		Considering the different project models Lauesen explains, we have mainly used the two-step approach, meaning that we focus on domain level and design level requirements.
		\subsubsection{Goal level}
			We used the goal level requirements in order to understand the context and what the different stakeholders expected, needed and wanted from our system.
		\subsubsection{Domain level}
			Our domain level requirements are task descriptions and feature requirements. These are used to show what should be possible to with the system and provide the context to the features.
		\subsubsection{Product level}
			The product level requirements define the features as well as the data too be included in our system.
		\subsubsection{Design level}
			We have not gone in on implementation issues such as how to store the user's data but rather focused on what was important for the users, such as information to be displayed.
		
		\subsection{Data model}
A data model is an abstract model of what data is needed in a system. It is not necessarily a requirement but in our case we use the model as a requirement.
	
		\subsubsection{Application}
		We chose the user as a starting point and tried to investigate what kind of data that we would need to be able to give the functionality required.
		\subsubsection{Why chosen}
		We used it to realize which kind of data the system would need.
		\subsubsection{Outcome}
	We got a lot of definitions out of putting it together since we needed to discuss what we meant by the entities in the model (coming in a data dictionary in release 2).

		\subsection{Virtual Windows}
			A Virtual Window is basically a graphic screen with no actually functions or menus. It is used for visualizing the System's data so that the user and the developer can relate to it in a good manner. It can be used for developing the user interface.
			\subsubsection{Application}
				We used Virtual Widows to create a simple data model for the Application that the user interacts with the System. With the Virtual Windows and the Design workshop a suitable screen prototype could be made.
			\subsubsection{Why chosen}
				We chose to create some Virtual Windows because we wanted to know more of the data structure of the user part of the System.
			\subsubsection{Outcome}
				We got clearer view on how the system would interact with the customer and what kind of data structure was needed.
		\subsection{Context diagram} \label{subsec:context}
		A picture of how the system fits in to/interacts with its inner domain. It is used to realize what systems/people directly interacts with the product. The outer domain can also be included to give even better understanding of how the system fits into the surroundings.
			\subsubsection{Application}
			We chose the user as a starting point and reasoned about what the user needed to use the product for, from that we realized that the product needed to interact with a couple of systems. Then we reasoned about why the government wanted the product (to increase the use of public transport) which got us to realize that they would want statistics from the system.
			
			After release 2 we got the tip to extend the context diagram to include the outer domain as well. When we looked at which stakeholders that had not been included in the first version we saw that the product owner should have been in the inner domain. We also added Competitors and the regional public transportation administrators to the diagram.
			
			\subsubsection{Why chosen}
			We wanted to get an overview of how the system interacts with the actors and who might be affected by the system.
			\subsubsection{Outcome}
			When we were discussing the context diagram we realized that we were missing a stakeholder that we did not find during the stakeholder analysis. The missing stakeholder was the government that wants to get statistics from the system. 
			
			When adding the outer domain to the context diagram we realized that the product owner should have been in the inner domain. We also added competitors as a stakeholder, something we had not thought to do before since we didn't think they affected us - but they do since if the user decide to use them instead of us the product will not be successful.

		\subsection{QUPER}
		Used for quality requirements to deal with the problem of knowing if a little better for example performance would improve the product a lot or just be unnecessary. It is a way to see clearly in what range we want our quality requirements to be/how hard we want to work to satisfy them to a certain degree.
			\subsubsection{Application}
			We tried out QUPER on some of our quality requirements, for example how long time it takes from a press on the update button to the trips being shown.
			\subsubsection{Why chosen}
			When we tried to use QUPER on some quality requirements we realised that it is hard to compare ourselves with other companies since to our knowledge there is no other company that shows the trips to multiple locations simultaneously. We tried to compare ourselves with Skånetrafiken but since they only show the trips to one destination we had difficulties scaling their results to an application with multiple destinations. The barriers also became a problem but we have estimated when there is a need for big structural reorganization. 
			
			The breakpoints seems the most useful and would have worked with or without the rest of the QUPER model. We have incorporated both the breakpoints and the barriers on some requirements.

			\subsubsection{Outcome}
			We would have liked to use the entire QUPER method on at least one of our quality requirements but because of the problems discussed above we had to settle for just specifying the breakpoints.		
		
		
		\subsection{Task Descriptions}
			Task descriptions specify the interactions between the product and the user. It is quite easy for the customer to validate since task descriptions speaks the "customer language". Task descriptions will also improve the understanding on a domain-level manner for both developers and customers.

			\subsubsection{Application}
				We went through as many functions that we could come up with and broke them down into tasks. 
			\subsubsection{Why chosen}
				Task descriptions were chosen to give a better understanding of the systems requirements in a domain-level manner.
			\subsubsection{Outcome}	
				In the process of describing tasks it became obvious that there were a lot more tasks than initially imagined. As a task was being described, subtasks emerged and thus an even deeper understanding of the system was acquired than previously suspected that the method would generate. There are probably more tasks to describe in the system than was done, however you have to realise where to stop. It is easy to dig very far into the tasks and thus generate a lot of paperwork.

	\section{Prioritization Methods/Techniques}
	Prioritization is used to see which requirements are the most important for different stakeholders. This can later be used to see which features to include in early releases through release planning. There are a couple of different methods to use for prioritization depending on if you just want to see which requirements are more important than others or if you also want to know how much more important. Different aspects can also be taken into account during prioritization. 
	
	In our prioritizations we have used importance as the aspect to compare the requirements against, since we feel that this is the most important aspect when doing release planning. Had we had more time we would also have liked to have done a prioritization based on the risk of the different requirements since it would have been practical to see how much risk the different requirements introduce to the project.
	
	All requirements have also been given a cost which according to the article about prioritization in the compendium also seems to be counted as a prioritization. We estimated the cost by setting a time in hours and the "prioritization" was done by estimating the actual cost of implementing the requirement.

	\subsection{Cumulative Voting (The 100-dollar method)}
		The 100-dollar method is used to prioritize requirements. The stakeholder in question is given a fixed sum of money (for example 100 dollars), this amount is then divided to the different requirements to get the prioritization. The result is that the requirements are prioritized on a ratio scale which means that it is possible to see how much more important one requirement is compared to another.   
		\subsubsection{Application}
			The 100-dollar method was used when two of the stakeholders prioritized the requirements - the users and the Swedish government (we played the role of the government during this prioritization). The stakeholders were given 100 dollars each to prioritize. This prioritization was done before all requirements were specified and we chose to let all the requirements keep their priority when new requirements were added. The new requirements were compared to already existing requirement's priority and given a priority so that the 100 dollar were exceeded but the prioritization still correct. For the release planning the priorities have been normalized to work with all other stakeholder priorities. 
		\subsubsection{Why chosen}
			The method is an easy way to get an overview over which requirements that is the most important. We also liked the fact that it is possible to see how much more important a requirement is compared to another.
		\subsubsection{Outcome}
			We got a prioritization from two of the stakeholders that we converted to benefit in our reqT model. This priority have been used both by us to figure out which requirements to give the most attention and to be able to do a release planning (then with normalized benefits).

	\subsection{Ranking (Insertion sort)}
		Insertion sort gives all the requirements ranked on an ordinal scale, all ties have to be broken so no two requirements have the same priority.
		\subsubsection{Application}
			Insertion sort was used to rank our requirements against each other to be able to see which are more important than the rest. The method was used to prepare for the second computer lab.
		\subsubsection{Why chosen}
			The method was used when prioritizing some of our requirements for the computer lab. We used it for a while in our project as well but decided that we would rather have all requirements prioritized either with cumulative voting or numerical assignment since we think that it gives more information about how they relate to each other in priority.
		\subsubsection{Outcome}
			We saw that insertion sort is practical to get a clear picture over which requirements we consider more important than others, but it can not tell us how much more important they are. We also considered the method a bit too time consuming and therefore choose a faster method when letting the customer prioritize.  			
		
	\subsection{Numerical assignment (Grouping)}
		This was the method used when we had a prioritization session with our customer.
		To find out what the customer considered most important in the finished system we asked them to prioritize all of the requirements, but only gave them five groups to place each requirement in.
		\subsubsection{Application}
			The customer was asked to make a prioritization of the requirements we had so far, by ranking them from 1 to 5, where 1 was the highest priority and 5 was the lowest.
		\subsubsection{Why chosen}
			We wanted to get an idea of what our customers thought was most important and to see if that was in line with our point of view. We also wanted to get the input we needed to be able to do a release planning in a later stage.
		\subsubsection{Outcome}
			All of the requirements ended up divided into the five groups so that it is more clear what to focus on. We will use these results when performing the release planning, the priorities will then be normalized to work together with the prioritization from the other stakeholders.

	\section{Validation techniques}
	Validating requirements is a crucial part in requirements engineering. It is a way to trace the customer's goals and demands to the requirements it has stated. There are two ways of validation requirements, top-down and bottom-up. In the top-down version the analyst first looks at the goals and demands and then tries to figure out if they are all covered by the requirements. In the bottom-up version the analyst instead starts from the requirements end and checks if they all describe the goals and demands.
						
			\subsection{CRUD}
				The CRUD matrix is a way to find missing parts in the requirements and get an overview of what is checked against what by describing the relations between tasks and entities in the system. The entities are taken from the datamodel and the tasks are the same tasks that are written in the requirements specification. The method is based on a matrix where the columns contain the entities and the rows contains the tasks. This matrix is then filled by the letters c, r, u, d and o that stands for in which ways the tasks relates to the entities. 
				
				This CRUD-matrix was done to validate the system we are customers to (Boogle) since it was one of the criteria in their validation checklist.
			
	\begin{center}
		
		
			\begin{tabular}{|l||c|c|c|c|c|}
			\hline 
			\textbf{TASK \textbackslash ENTITY} & Participant & External calendar & Event planner & Group & Event \\ 
			\hhline{|=||=|=|=|=|=|}
			Register account & & & C & & \\ 
			\hline 
			Login & & & & & \\ 
			\hline 
			Forgotten password & U & & & & \\ 
			\hline 
			Create event & R U O & & & U & C \\ 
			\hline 
			Accept group invitation & C & R O & & U & \\ 
			\hline 
			Invite users to group & & & & U & \\ 
			\hline 
			Create groups & & & U & C & \\ 
			\hline 
			Invite groups & O & & & O & \\ 
			\hline 
			Remove participants from group & R D O & U D & & R U & \\ 
			\hline 
			Edit event & & & & & R U \\ 
			\hline 
			Delete event & & & & & D \\ 
			\hhline{|=||=|=|=|=|=|}
			\textbf{MISSING} & & (C) & (R) \textbf{D} (O) & \textbf{D} & \textbf{O} \\ 
			\hline 
			\end{tabular} 
	
		\end{center}
			After our CRUD-check of the Boogle Calendar system we looked at the different missing parts. Of the six missing parts we decided that we don't think that it is the system's job to be able to create external calendars, have an overview of all event planners or look at (read) one event planner. The other parts we found missing were sent to the developers as critical issues.

			
			\subsection{Our Checklist}
				To help our customers in validating our system we made a validation checklist. We based our checklist on the example checklists from the course book and the compendium. We went through both checklists and discussed as a group which criteria we wanted the customers to validate against, those that we found relevant were added to our own validation checklist. While creating our checklist we realized that we were missing some things, some we corrected directly and some were added to a to do list to be fixed before the final release. Some criteria were added to the checklist on purpose even though we knew that we were missing it in the product (for example some types of quality requirements), the purpose of this was that we wanted to find out if our customers found these criteria important. Unfortunately the customers did not comment on if they had any examples of what was missing, just that they were missing. However, their priority of the criteria said that they did not consider it critical so it is not a big problem. We were hoping to get more out of the validation feedback, but at least we got some things to look at, and the more unclear answers we could always ask the customer about. We consider the writing of the checklist to have been a bit more beneficial for us since we found a lot of things to improve when we considered the criteria. Even though we feel this way we could not have done without the customers validation feedback since even if we think it is perfect it might not be what they actually asked for.
				Before sending in the last release we will try to solve the most critical issues that the customers found to improve our system as much as possible.
				 			
			\subsection{Validating with customer checklist}
				We got a checklist from the group that design the requirement specification for our product, Boogle Calendar. We checked what was missing or not and prioritized the different validation checks. It was a good experience since we could get a clearer overview of what they had made of the project and we got the chance to reflect and give constructive feedback to the group. We could really see the benefit of validating the requirement specification, since in a project in the "real world" validation of the requirement specification would happen more often. This will give the customer and the developer an acknowledgement of what is finished and a chance to lead the project in the right direction.

			\subsection{Goal-Domain tracing}
				%HANNES LEVERERAR!
				%Tänk på: adapt the validation to the context and provide rationale for the chosen validation techniques.
				To validate our own requirements we decided to do a Goal/Domain Tracing. This means that for each goal we listed which domain requirements that implemented that specific goals. This leads to a completeness check for both the goals and the domain level requirements. We found some requirements that was not possible to fit into a existing requirement and this made us elicit new goals for our stakeholders. When grouping the requirements under a specific goal also gave us a better understanding of what that specific goal should consist of, which lead to some minor adjustment in the wording of the goals to make them clearer. We also found that one of our goals was not implemented by any of the domain requirements, which is a critical problem. Either we were missing requirements or the goal is not correct. 

	\section{Release planning}
	% mer beskrivning kanske
	% mer jul
	% motiverat customer borttagning
	% bara en release och senare.
	%
		Release planning is (just as many other aspects in this document) vital for projects success. Basically release planning is about determining which requirements and features that should be included in which release. Determining this is NP-hard and often have more than one solution. For reference, when we performed the release planning for our project, we managed to find approximately 450000 different solutions in 2 minutes (this was of course not done by hand).

		\subsection{Release planning by hand}
		\label{sec:release_planning}
			As our project does not contain a lot of dependencies between features it was not that hard to generate an adequate solution. However, if the number of dependencies increase, planning by hand would be much more difficult. Also as the dependencies increase in number it becomes more obvious that release planning actually is a NP-hard problem.

		\subsection{Release planning with reqT}
			Release planning with reqT is not a valid method if you only plan to do it once and the project isn't that complex. However, as for the most project you will have multiple releases over a long period of time, and keeping track of what requirement or feature that has or has not been implemented is a major task. This can however be made somewhat simpler with reqT if you keep track of the current status of the requirements and features in the project.

			It is not unusual that you do not stick to the plans that has been laid out. This can be both positive and negative, positive if you manage to get more things done than what was originally planned, negative if you did not manage to accomplish what was originally planned. When this happens it is necessary to reschedule for the next release. This cumbersome task can be managed quite easily with reqT.

			\subsubsection{Our experiences with reqT}
				Initially the work load for the people that are in charge of the release planning is quite high. All requirements that should be included in the release planning has to be specified, given a cost to implement from each development team, given a benefit for each stakeholder, and constraints such as feature and requirement precedences much be entered. This is usually provided from other part of the project and thus the people responsible for the release planning doesn't have to collect this information from the required sources. However it still has to be entered into the model. This is not a problem if done continuously throughout the project.

				The problem we faced here was that we only performed the release planning once and at the end of the project. Up to this point all the requirements had been specified by different people, in different small models and could not easily be tracked and managed. This was very likely due to lack of understanding of the reqT tool in the group. If we were to do this again we would most likely have structured the requirements differently as to make tasks such as release planning easier.

				Some other things we stumbled upon as we tried to do the release planning were that there were some limitations in reqT that we did not know of, such as a Capacity could not exceed the value 1000, this is to limit the number of possible solutions and thus limiting the calculation time. If you do exceed Capacity values of 1000, reqT can never find a solution as it only says ''Inconsistency Found''. When we lowered the Capacity values we still managed to find roughly 450000 solutions in 2 minutes. This is most likely due to the fact that there aren't many constraints between the requirements and features in our project.

				The model representing the solution was somewhat horrific, and you had to break down the model in smaller instances to be able to get a grip on what the solution was. All releases in the solution contained all of the features and requirements that was in the original model but some of these had 0 cost and benefit. This means that when you looked at the model in text, it was littered with requirements and features that wasn't in the release, and thus if you tried to generate a graphical representation of the solution it was completely unreadable. Once the model had been broken down and all of the ''ghost features'' was removed the model was much easier to comprehend.

	\section{Future work}
	%For next release/future
If we were to continue with the project it would be beneficial to elicit more requirements. In general, our quality requirements could need more work. In order to improve and find new quality requirements we would try new elicitation techniques. Some of the techniques we would want to use are:
	\subsection*{Prototyping}
	Even though we did some mock ups and had a design workshop, it could be beneficial to create an interactive prototype that we could show for our client and users. An interactive prototype enables a tester of the prototype to really understand how the system should work and also give good feedback on improvements.
	\subsection*{Risk analysis}
	In this project we have to large part ignored risk analysis. Risk analysis could be used as an elicitation technique in order to identify high risk areas and ways to minimize the risk.
	\subsection{Cost/benefit analysis}
	Even though this has been an integrated part of different stages, it would be a good idea to do a more formal cost/benefit analysis with more time on our hands. A cost/benefit analysis would greatly improve our quality our requirements as we could identify which requirements to focus on.

	\section{Reflection}
	%What was successful/what was challenging
	%Example, what have we learned?
	%What could have been done differently?
	%What we have learned related to learning objectives




	Below we discuss reflections about the process and how the project is going. It is divided into three phases, named after the three releases.
	
\subsection{R1}
While working with our project we have encountered several elicitation barriers. One that we noticed in particular is that the stakeholder cannot express what they need. We have also noticed that stakeholders can have conflicting views within themselves. Another barrier has been that our clients have suggested solutions rather than expressing their needs and demand.

An obstacle we have met is that we tend to forget to use several elicitation techniques. It is easy to get hung up on just brainstorming. Our group does not only have a big domain knowledge but also consists of potential end users. This gives us a false sense of security, as we think that we ourselves incorporate the different stakeholders' opinions and experiences and because of this we sometime get the feeling that we already know everything that the product should have and how it should work. The problem with that is that might not be what the average user wants with the product or what the customers wants. Since we are designing the requirement specification for them it is their opinion that matters and it is their decisions that are final for the most parts. A solution to all these problems is to carry out different elicitation techniques and contact different stakeholders anyway and also to take our customers thought into account a bit more. It is important to hear everyone's opinion, since we know from experience that more input will yield better results and our task is not to decide what the product should do, our task is to deliver a requirement specification.

During the initial phase of the project it has been difficult to divide the workload. This is because we needed to be on the same page regarding several matters. However, trying to work all eight together has resulted inefficiency. This is something we are working with and we will try to divide the work into smaller independent tasks. We believe that this approach will result in higher efficiency.
\subsection{R2}
These weeks we have worked closer to more stakeholders, not only clients but potential users as well. When working with users as well we realized that their wishes sometimes collide with the wishes of our clients. Since the project is for our clients, it is more important to satisfy them, but still letting them know that the users might think otherwise.

We have noticed an increased efficiency when we divided assignments to people within the group and worked alone or in couples instead of the whole group. This has led to more concrete tasks to do and a better result.

\subsection{R3}

For the third release we have been working a lot with the comments we have gotten from our project handler and our customers. We have also validated release two that we got from the group that we are customers to, boogleoodle, and we have done a release plan for our product. 

Fixing the comments has taken quite some time to do. Not because there were a lot of them, but because we wanted to do them as good as possible. Also, some of them we have had to ask about once more because we did not understand what the comment was about. 

Validating the boogleoodle requirement specification was not easy. It was hard to identify all the \textbf{something} and to find out if the specification lived up to them. We first did the validation individually and then some of us sat together and merged our different opinions into one final validation report. This way of doing the validation incorporated every member in the group in some way but it did not make the work with our own requirement specification come completely to a halt. Also, because the sub-part of the group that finalized the report could discuss a lot the result was quite good. The drawback is that some of us had to do the validation multiple times and lost some time when they could have worked with our project instead. 

Release planning turned out to be quite hard as well, but more on this in section \ref{sec: release_planning}, Release Planning.

	\section{Personal statements}
In this paragraph each group member briefly explains its individual contributions to the project result.
	
	\subsection{Alexander}
		\subsubsection{R1}
		I have been mainly involved in the elicitation and the selection of elicitation techniques. I have also taken part of the group discussion, brainstorming and meetings with customers.
		\subsubsection{R2}
		Have done the workshop with our clients where I took part in planning, execution and summarizing the results. I have also worked on some virtual windows for the user application that we presented to our clients. 
		\subsubsection{R3}
			CRUD-check. I have mostly checked our requirements and our text in System Requirements for unambiguous contents. Also a big deal of "fixing" minor stuff in the System Requirements.	
			
	\subsection{Emma}
		\subsubsection{R1}
		So far I have except for the common brainstorming, customer meetings and general work been working on a context diagram, data model and a first user task.
		\subsubsection{R2}
	In this release I have worked in particular with QUPER, quality goals and prioritization. I have also been involved in producing the validation checklist in cooperation with the rest of the group.
		\subsubsection{R3}
		I have mostly worked with validating the Boogle project according to their checklist and writing down our experiences with both validation and prioritization. I have also been involved in making the new and improved context diagram.
			
	\subsection{Fredrik}
		\subsubsection{R1}
		I have contributed to the data model and the elicitation technique similar companies. Except for that I have been involved in the brainstorming, customer meetings and common work.
		\subsubsection{R2}
		I have been participating in workshop with users and meetings with the customers. Done some more brainstorming, which resulted in a couple of new requirements. I've also been working on putting the requirements in the right place and corrected unambiguous requirements.
		\subsubsection{R3}
		For release 3 I've been busy with with the release planning. The release planning was made with the help of reqT. Also worked with the validation of the system.
		
	\subsection{Hannes}
		\subsubsection{R1}
		I have helped producing the context diagram and planned for future quality requirements work. I have also gone to the meetings with stakeholders and been in the group discussions and brainstorming.
		\subsubsection{R2}
		Have worked on our with the requirements in reqT as well as correcting/clarifying them.  
		\subsubsection{R3}
		Validation, stakeholders
		For this release I have been working with validation of our own requirements by doing a goal-domain tracing. I have also done a lot of corrections of our requirements according to the comments from the validation report. 
	
	
	\subsection{Johan}
		\subsubsection{R1}
		I have taken part in the elicitation process aswell as helping out with other tasks such as the context diagram. Further have I also been involved in the customer meetings and out internal brainstorming.
		\subsubsection{R2}
		Have worked with producing mock ups and taken part in our supplier's workshop. I also specified some requirements and worked in reqT so that all requirements were coherent.
		\subsubsection{R3}
		I have been working with creating a Crud-matrix and locating more of the stakeholders' goals. I have also kept working with keeping all requirements consistent and coherent.
			
	
	\subsection{Martin}
		\subsubsection{R1}
		I have mostly coordinated the work, documenting the project experiences and trying different Gantt chart software. Have also had contact with our suppliers and participated in meetings with them and with our clients.
		\subsubsection{R2}
		I planned the workshop and lead it together with Alexander. Have had contact with our suppliers and also took part in their workshop. Also helped out with clarifying some requirements and updating project experiences.
		\subsubsection{R3}
			presentation
	
	\subsection{Mattias}
		\subsubsection{R1}
		I have been working with tools and setting up the document and file infrastructure. Other than this I have participated in the meetings.
		\subsubsection{R2}
		For this release I've mostly been working on the tasks and multiple refactorisations of the aforementioned tasks. Other than that I've been building a script to automatically generate all the external tex-files from scala files to make sure that the latest version of the models are in the system requirements document.
		\subsubsection{R3}
		For release 3 I've been busy with with the release planning. The release planning was made with the help of reqT. I also rebuilt the build script. It's better now.

	\subsection{Philip}
		\subsubsection{R1}
	I have mostly been writing in this document and participated in discussions. I've also handled a lot of the contact to and from our costumer group and the group we are customers to.
		\subsubsection{R2}
		Been working a bit with the design requirements and I have been working with putting requirements in the right section and I've been editing requirements to be easier to understand and more specified and fixed minor bugs
		\subsubsection{R3}
		For this release I've held the project presentation together with Martin, been working on bettering a lot of the requirements by modifying the `Example' part of the requirements. I have also fixed issues that was stated by the customer in the validation report and other minor things we wanted to change. 

\end{document}
